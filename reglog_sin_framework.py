# -*- coding: utf-8 -*-
"""RegLog_Sin_Framework.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xp4rUf7AFW8A8D-e07ZfASA29hl1Teln

# Dataset management
"""

import pandas as pd

seeds = pd.read_csv('Pumpkin_Seeds.csv')
seeds.head()

seeds = seeds.sample(frac=1).reset_index(drop=True)
seeds.head()

seeds['Class'].replace(['Çerçevelik', 'Ürgüp Sivrisi'],[0, 1,], inplace= True)
seeds.head()

X = seeds.drop(['Class'], axis=1)
y = seeds[['Class']]

test_size=0.2
#X_train = X.sample(frac=0.8)

X_train = X[:int(X.shape[0]*(1-test_size))]
X_test = X[int(X.shape[0]*(1-test_size)):]
y_train = y[:int(X.shape[0]*(1-test_size))]
y_test = y[int(X.shape[0]*(1-test_size)):]

print(X_train.shape,y_train.shape, X_test.shape, y_test.shape)

def minmax_norm(df):
  return (df - df.min()) / ( df.max() - df.min())

X_test = minmax_norm(X_test)
X_train = minmax_norm(X_train)

X_train.head()

"""# Funciones"""

import numpy as np

def perceptron(X_train, params):
  YS=[]  
  for i in X_train.index:
    vector_x = [1]
    for col in X_train.columns:
      vector_x.append(X_train.loc[i,col])
    vector_x = np.array(vector_x)
    YS.append((vector_x*params).sum())
  return np.array(YS)

def sigmoide(YS):
  SIGS=[]
  for ys in YS:
    SIGS.append(1/(1+np.exp(ys*-1)))
  y_pred=[round(e) for e in SIGS]
  return np.array(SIGS), y_pred

def crossentropy(y_train, SIG):
  cross=[]
  y_inds=y_train.index
  for n in range(len(SIG)):
    y = y_train.loc[y_inds[n],'Class']
    yp = SIG[n]
    ce= -(y*np.log(yp) + (1-y)*np.log(1-yp))
    cross.append(ce)

  loss = np.mean(np.array(cross))
  return loss

def gradient_descent(params, alfa, y_pred, loss):
  #print('Old parameters', params)
  for p in range(len(params)):
    params[p] = params[p]-(alfa/len(y_pred))*loss
  #print('New parameters', params)
  return params

def accuracy(y_pred, y_train):
  sum=0
  for n in y_train.index:
    if y_pred[n-y_train.index[0]] == y_train.loc[n,'Class']:
      sum += 1
  print('Accuracy:', sum/len(y_pred))
  #return (sum/len(y_pred))

"""# Regresión Logística"""

#Coeficiente de aprendizaje
alfa = 0.4

#Random initial parameters
from random import random

params =[]
for i in range(X_train.shape[1]+1):
  params.append(random())

params = np.array(params)
params

# Entrenamiento del modelo
epoch=0
losses = [100]
while losses[-1] == min(losses):
  YS = perceptron(X_train, params)
  SIG, y_pred = sigmoide(YS)
  loss = crossentropy(y_train, SIG)
  losses.append(loss)
  epoch +=1
  #print('Epoch:', epoch)
  #print('Loss:', loss)
  params = gradient_descent(params, alfa, y_pred, loss)
print('Epochs:', epoch)
accuracy(y_pred, y_train)

"""## Testing del modelo"""

YS = perceptron(X_test, params)
SIG, y_pred = sigmoide(YS)
accuracy(y_pred, y_test)